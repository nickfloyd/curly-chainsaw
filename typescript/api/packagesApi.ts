/**
 * GitHub v3 REST API
 * GitHub\'s v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BasicError } from '../model/basicError';
import { Package } from '../model/package';
import { PackageVersion } from '../model/packageVersion';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.github.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PackagesApiApiKeys {
}

export class PackagesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: PackagesApiApiKeys, value: string) {
        (this.authentications as any)[PackagesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Delete a package for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     */
    public async packagesDeletePackageForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageForAuthenticatedUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     * @summary Delete a package for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     */
    public async packagesDeletePackageForOrg (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageForOrg.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageForOrg.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesDeletePackageForOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     * @summary Delete a package for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     */
    public async packagesDeletePackageForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesDeletePackageForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Delete a package version for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesDeletePackageVersionForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesDeletePackageVersionForAuthenticatedUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     * @summary Delete package version for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesDeletePackageVersionForOrg (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageVersionForOrg.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageVersionForOrg.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesDeletePackageVersionForOrg.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesDeletePackageVersionForOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
     * @summary Delete package version for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesDeletePackageVersionForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesDeletePackageVersionForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesDeletePackageVersionForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesDeletePackageVersionForUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesDeletePackageVersionForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns all package versions for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get all package versions for a package owned by the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param page Page number of the results to fetch.
     * @param perPage The number of results per page (max 100).
     * @param state The state of the package, either active or deleted.
     */
    public async packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, page?: number, perPage?: number, state?: 'active' | 'deleted', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}/versions'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'active' | 'deleted'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<PackageVersion>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns all package versions for a package owned by an organization.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get all package versions for a package owned by an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     * @param page Page number of the results to fetch.
     * @param perPage The number of results per page (max 100).
     * @param state The state of the package, either active or deleted.
     */
    public async packagesGetAllPackageVersionsForPackageOwnedByOrg (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, page?: number, perPage?: number, state?: 'active' | 'deleted', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}/versions'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByOrg.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByOrg.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByOrg.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'active' | 'deleted'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<PackageVersion>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns all package versions for a public package owned by a specified user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get all package versions for a package owned by a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     */
    public async packagesGetAllPackageVersionsForPackageOwnedByUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}/versions'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesGetAllPackageVersionsForPackageOwnedByUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<PackageVersion>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<PackageVersion>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     */
    public async packagesGetPackageForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Package;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageForAuthenticatedUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Package;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Package");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package in an organization.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     */
    public async packagesGetPackageForOrganization (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Package;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageForOrganization.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageForOrganization.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesGetPackageForOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Package;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Package");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package metadata for a public package owned by a user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     */
    public async packagesGetPackageForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Package;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesGetPackageForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Package;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Package");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package version for a package owned by the authenticated user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package version for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesGetPackageVersionForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PackageVersion;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesGetPackageVersionForAuthenticatedUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PackageVersion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PackageVersion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package version in an organization.  You must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package version for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesGetPackageVersionForOrganization (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PackageVersion;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageVersionForOrganization.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageVersionForOrganization.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesGetPackageVersionForOrganization.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesGetPackageVersionForOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PackageVersion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PackageVersion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a specific package version for a public package owned by a specified user.  At this time, to use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Get a package version for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param packageVersionId Unique identifier of the package version.
     * @param username The handle for the GitHub user account.
     */
    public async packagesGetPackageVersionForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, packageVersionId: number, username: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PackageVersion;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesGetPackageVersionForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesGetPackageVersionForUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesGetPackageVersionForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesGetPackageVersionForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PackageVersion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PackageVersion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists packages owned by the authenticated user within the user\'s namespace.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary List packages for the authenticated user\'s namespace
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param visibility The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
     */
    public async packagesListPackagesForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', visibility?: 'public' | 'private' | 'internal', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Package>;  }> {
        const localVarPath = this.basePath + '/user/packages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesListPackagesForAuthenticatedUser.');
        }

        if (packageType !== undefined) {
            localVarQueryParameters['package_type'] = ObjectSerializer.serialize(packageType, "'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container'");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'public' | 'private' | 'internal'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Package>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Package>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists all packages in an organization readable by the user.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary List packages for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param org The organization name. The name is not case sensitive.
     * @param visibility The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
     */
    public async packagesListPackagesForOrganization (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', org: string, visibility?: 'public' | 'private' | 'internal', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Package>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesListPackagesForOrganization.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesListPackagesForOrganization.');
        }

        if (packageType !== undefined) {
            localVarQueryParameters['package_type'] = ObjectSerializer.serialize(packageType, "'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container'");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'public' | 'private' | 'internal'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Package>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Package>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists all packages in a user\'s namespace for which the requesting user has access.  To use this endpoint, you must authenticate using an access token with the `packages:read` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary List packages for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param username The handle for the GitHub user account.
     * @param visibility The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
     */
    public async packagesListPackagesForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', username: string, visibility?: 'public' | 'private' | 'internal', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Package>;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesListPackagesForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesListPackagesForUser.');
        }

        if (packageType !== undefined) {
            localVarQueryParameters['package_type'] = ObjectSerializer.serialize(packageType, "'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container'");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'public' | 'private' | 'internal'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Package>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Package>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores a package owned by the authenticated user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Restore a package for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param token package token
     */
    public async packagesRestorePackageForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, token?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageForAuthenticatedUser.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores an entire package in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     * @summary Restore a package for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     * @param token package token
     */
    public async packagesRestorePackageForOrg (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, token?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageForOrg.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageForOrg.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesRestorePackageForOrg.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores an entire package for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     * @summary Restore a package for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     * @param token package token
     */
    public async packagesRestorePackageForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, token?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesRestorePackageForUser.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores a package version owned by the authenticated user.  You can restore a deleted package version under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.
     * @summary Restore a package version for the authenticated user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesRestorePackageVersionForAuthenticatedUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageVersionForAuthenticatedUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesRestorePackageVersionForAuthenticatedUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores a specific package version in an organization.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     * @summary Restore package version for an organization
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param org The organization name. The name is not case sensitive.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesRestorePackageVersionForOrg (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, org: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageVersionForOrg.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageVersionForOrg.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling packagesRestorePackageVersionForOrg.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesRestorePackageVersionForOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restores a specific package version for a user.  You can restore a deleted package under the following conditions:   - The package was deleted within the last 30 days.   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package\'s namespace first.  To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition: - If `package_type` is not `container`, your token must also include the `repo` scope. - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
     * @summary Restore package version for a user
     * @param packageType The type of supported package. Packages in GitHub\&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub\&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub\&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
     * @param packageName The name of the package.
     * @param username The handle for the GitHub user account.
     * @param packageVersionId Unique identifier of the package version.
     */
    public async packagesRestorePackageVersionForUser (packageType: 'npm' | 'maven' | 'rubygems' | 'docker' | 'nuget' | 'container', packageName: string, username: string, packageVersionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore'
            .replace('{' + 'package_type' + '}', encodeURIComponent(String(packageType)))
            .replace('{' + 'package_name' + '}', encodeURIComponent(String(packageName)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'package_version_id' + '}', encodeURIComponent(String(packageVersionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'packageType' is not null or undefined
        if (packageType === null || packageType === undefined) {
            throw new Error('Required parameter packageType was null or undefined when calling packagesRestorePackageVersionForUser.');
        }

        // verify required parameter 'packageName' is not null or undefined
        if (packageName === null || packageName === undefined) {
            throw new Error('Required parameter packageName was null or undefined when calling packagesRestorePackageVersionForUser.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling packagesRestorePackageVersionForUser.');
        }

        // verify required parameter 'packageVersionId' is not null or undefined
        if (packageVersionId === null || packageVersionId === undefined) {
            throw new Error('Required parameter packageVersionId was null or undefined when calling packagesRestorePackageVersionForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
