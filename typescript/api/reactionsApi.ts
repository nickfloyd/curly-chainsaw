/**
 * GitHub v3 REST API
 * GitHub\'s v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BasicError } from '../model/basicError';
import { Reaction } from '../model/reaction';
import { ReactionsCreateForCommitCommentRequest } from '../model/reactionsCreateForCommitCommentRequest';
import { ReactionsCreateForIssueCommentRequest } from '../model/reactionsCreateForIssueCommentRequest';
import { ReactionsCreateForIssueRequest } from '../model/reactionsCreateForIssueRequest';
import { ReactionsCreateForPullRequestReviewCommentRequest } from '../model/reactionsCreateForPullRequestReviewCommentRequest';
import { ReactionsCreateForReleaseRequest } from '../model/reactionsCreateForReleaseRequest';
import { ReactionsCreateForTeamDiscussionCommentInOrgRequest } from '../model/reactionsCreateForTeamDiscussionCommentInOrgRequest';
import { ReactionsCreateForTeamDiscussionInOrgRequest } from '../model/reactionsCreateForTeamDiscussionInOrgRequest';
import { ValidationError } from '../model/validationError';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.github.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ReactionsApiApiKeys {
}

export class ReactionsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ReactionsApiApiKeys, value: string) {
        (this.authentications as any)[ReactionsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
     * @summary Create reaction for a commit comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionsCreateForCommitCommentRequest 
     */
    public async reactionsCreateForCommitComment (owner: string, repo: string, commentId: number, reactionsCreateForCommitCommentRequest: ReactionsCreateForCommitCommentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsCreateForCommitComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsCreateForCommitComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsCreateForCommitComment.');
        }

        // verify required parameter 'reactionsCreateForCommitCommentRequest' is not null or undefined
        if (reactionsCreateForCommitCommentRequest === null || reactionsCreateForCommitCommentRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForCommitCommentRequest was null or undefined when calling reactionsCreateForCommitComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForCommitCommentRequest, "ReactionsCreateForCommitCommentRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.
     * @summary Create reaction for an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param reactionsCreateForIssueRequest 
     */
    public async reactionsCreateForIssue (owner: string, repo: string, issueNumber: number, reactionsCreateForIssueRequest: ReactionsCreateForIssueRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsCreateForIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsCreateForIssue.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling reactionsCreateForIssue.');
        }

        // verify required parameter 'reactionsCreateForIssueRequest' is not null or undefined
        if (reactionsCreateForIssueRequest === null || reactionsCreateForIssueRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForIssueRequest was null or undefined when calling reactionsCreateForIssue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForIssueRequest, "ReactionsCreateForIssueRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
     * @summary Create reaction for an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionsCreateForIssueCommentRequest 
     */
    public async reactionsCreateForIssueComment (owner: string, repo: string, commentId: number, reactionsCreateForIssueCommentRequest: ReactionsCreateForIssueCommentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsCreateForIssueComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsCreateForIssueComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsCreateForIssueComment.');
        }

        // verify required parameter 'reactionsCreateForIssueCommentRequest' is not null or undefined
        if (reactionsCreateForIssueCommentRequest === null || reactionsCreateForIssueCommentRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForIssueCommentRequest was null or undefined when calling reactionsCreateForIssueComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForIssueCommentRequest, "ReactionsCreateForIssueCommentRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
     * @summary Create reaction for a pull request review comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionsCreateForPullRequestReviewCommentRequest 
     */
    public async reactionsCreateForPullRequestReviewComment (owner: string, repo: string, commentId: number, reactionsCreateForPullRequestReviewCommentRequest: ReactionsCreateForPullRequestReviewCommentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsCreateForPullRequestReviewComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsCreateForPullRequestReviewComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsCreateForPullRequestReviewComment.');
        }

        // verify required parameter 'reactionsCreateForPullRequestReviewCommentRequest' is not null or undefined
        if (reactionsCreateForPullRequestReviewCommentRequest === null || reactionsCreateForPullRequestReviewCommentRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForPullRequestReviewCommentRequest was null or undefined when calling reactionsCreateForPullRequestReviewComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForPullRequestReviewCommentRequest, "ReactionsCreateForPullRequestReviewCommentRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
     * @summary Create reaction for a release
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param reactionsCreateForReleaseRequest 
     */
    public async reactionsCreateForRelease (owner: string, repo: string, releaseId: number, reactionsCreateForReleaseRequest: ReactionsCreateForReleaseRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{release_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'release_id' + '}', encodeURIComponent(String(releaseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsCreateForRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsCreateForRelease.');
        }

        // verify required parameter 'releaseId' is not null or undefined
        if (releaseId === null || releaseId === undefined) {
            throw new Error('Required parameter releaseId was null or undefined when calling reactionsCreateForRelease.');
        }

        // verify required parameter 'reactionsCreateForReleaseRequest' is not null or undefined
        if (reactionsCreateForReleaseRequest === null || reactionsCreateForReleaseRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForReleaseRequest was null or undefined when calling reactionsCreateForRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForReleaseRequest, "ReactionsCreateForReleaseRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.  **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
     * @summary Create reaction for a team discussion comment
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param commentNumber The number that identifies the comment.
     * @param reactionsCreateForTeamDiscussionCommentInOrgRequest 
     */
    public async reactionsCreateForTeamDiscussionCommentInOrg (org: string, teamSlug: string, discussionNumber: number, commentNumber: number, reactionsCreateForTeamDiscussionCommentInOrgRequest: ReactionsCreateForTeamDiscussionCommentInOrgRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'comment_number' + '}', encodeURIComponent(String(commentNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsCreateForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsCreateForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsCreateForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'commentNumber' is not null or undefined
        if (commentNumber === null || commentNumber === undefined) {
            throw new Error('Required parameter commentNumber was null or undefined when calling reactionsCreateForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'reactionsCreateForTeamDiscussionCommentInOrgRequest' is not null or undefined
        if (reactionsCreateForTeamDiscussionCommentInOrgRequest === null || reactionsCreateForTeamDiscussionCommentInOrgRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForTeamDiscussionCommentInOrgRequest was null or undefined when calling reactionsCreateForTeamDiscussionCommentInOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForTeamDiscussionCommentInOrgRequest, "ReactionsCreateForTeamDiscussionCommentInOrgRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new \"[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)\" endpoint.  Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
     * @summary Create reaction for a team discussion comment (Legacy)
     * @param teamId The unique identifier of the team.
     * @param discussionNumber The number that identifies the discussion.
     * @param commentNumber The number that identifies the comment.
     * @param reactionsCreateForTeamDiscussionCommentInOrgRequest 
     */
    public async reactionsCreateForTeamDiscussionCommentLegacy (teamId: number, discussionNumber: number, commentNumber: number, reactionsCreateForTeamDiscussionCommentInOrgRequest: ReactionsCreateForTeamDiscussionCommentInOrgRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions'
            .replace('{' + 'team_id' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'comment_number' + '}', encodeURIComponent(String(commentNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling reactionsCreateForTeamDiscussionCommentLegacy.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsCreateForTeamDiscussionCommentLegacy.');
        }

        // verify required parameter 'commentNumber' is not null or undefined
        if (commentNumber === null || commentNumber === undefined) {
            throw new Error('Required parameter commentNumber was null or undefined when calling reactionsCreateForTeamDiscussionCommentLegacy.');
        }

        // verify required parameter 'reactionsCreateForTeamDiscussionCommentInOrgRequest' is not null or undefined
        if (reactionsCreateForTeamDiscussionCommentInOrgRequest === null || reactionsCreateForTeamDiscussionCommentInOrgRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForTeamDiscussionCommentInOrgRequest was null or undefined when calling reactionsCreateForTeamDiscussionCommentLegacy.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForTeamDiscussionCommentInOrgRequest, "ReactionsCreateForTeamDiscussionCommentInOrgRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.  **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
     * @summary Create reaction for a team discussion
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param reactionsCreateForTeamDiscussionInOrgRequest 
     */
    public async reactionsCreateForTeamDiscussionInOrg (org: string, teamSlug: string, discussionNumber: number, reactionsCreateForTeamDiscussionInOrgRequest: ReactionsCreateForTeamDiscussionInOrgRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsCreateForTeamDiscussionInOrg.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsCreateForTeamDiscussionInOrg.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsCreateForTeamDiscussionInOrg.');
        }

        // verify required parameter 'reactionsCreateForTeamDiscussionInOrgRequest' is not null or undefined
        if (reactionsCreateForTeamDiscussionInOrgRequest === null || reactionsCreateForTeamDiscussionInOrgRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForTeamDiscussionInOrgRequest was null or undefined when calling reactionsCreateForTeamDiscussionInOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForTeamDiscussionInOrgRequest, "ReactionsCreateForTeamDiscussionInOrgRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.  Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
     * @summary Create reaction for a team discussion (Legacy)
     * @param teamId The unique identifier of the team.
     * @param discussionNumber The number that identifies the discussion.
     * @param reactionsCreateForTeamDiscussionInOrgRequest 
     */
    public async reactionsCreateForTeamDiscussionLegacy (teamId: number, discussionNumber: number, reactionsCreateForTeamDiscussionInOrgRequest: ReactionsCreateForTeamDiscussionInOrgRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/discussions/{discussion_number}/reactions'
            .replace('{' + 'team_id' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling reactionsCreateForTeamDiscussionLegacy.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsCreateForTeamDiscussionLegacy.');
        }

        // verify required parameter 'reactionsCreateForTeamDiscussionInOrgRequest' is not null or undefined
        if (reactionsCreateForTeamDiscussionInOrgRequest === null || reactionsCreateForTeamDiscussionInOrgRequest === undefined) {
            throw new Error('Required parameter reactionsCreateForTeamDiscussionInOrgRequest was null or undefined when calling reactionsCreateForTeamDiscussionLegacy.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(reactionsCreateForTeamDiscussionInOrgRequest, "ReactionsCreateForTeamDiscussionInOrgRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Reaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.  Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
     * @summary Delete a commit comment reaction
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForCommitComment (owner: string, repo: string, commentId: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsDeleteForCommitComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsDeleteForCommitComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsDeleteForCommitComment.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForCommitComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.  Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
     * @summary Delete an issue reaction
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForIssue (owner: string, repo: string, issueNumber: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsDeleteForIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsDeleteForIssue.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling reactionsDeleteForIssue.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForIssue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.  Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
     * @summary Delete an issue comment reaction
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForIssueComment (owner: string, repo: string, commentId: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsDeleteForIssueComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsDeleteForIssueComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsDeleteForIssueComment.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForIssueComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`  Delete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
     * @summary Delete a pull request comment reaction
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForPullRequestComment (owner: string, repo: string, commentId: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsDeleteForPullRequestComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsDeleteForPullRequestComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsDeleteForPullRequestComment.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForPullRequestComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.  Delete a reaction to a [release](https://docs.github.com/rest/reference/repos#releases).
     * @summary Delete a release reaction
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForRelease (owner: string, repo: string, releaseId: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'release_id' + '}', encodeURIComponent(String(releaseId)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsDeleteForRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsDeleteForRelease.');
        }

        // verify required parameter 'releaseId' is not null or undefined
        if (releaseId === null || releaseId === undefined) {
            throw new Error('Required parameter releaseId was null or undefined when calling reactionsDeleteForRelease.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.  Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @summary Delete team discussion reaction
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForTeamDiscussion (org: string, teamSlug: string, discussionNumber: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsDeleteForTeamDiscussion.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsDeleteForTeamDiscussion.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsDeleteForTeamDiscussion.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForTeamDiscussion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.  Delete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @summary Delete team discussion comment reaction
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param commentNumber The number that identifies the comment.
     * @param reactionId The unique identifier of the reaction.
     */
    public async reactionsDeleteForTeamDiscussionComment (org: string, teamSlug: string, discussionNumber: number, commentNumber: number, reactionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'comment_number' + '}', encodeURIComponent(String(commentNumber)))
            .replace('{' + 'reaction_id' + '}', encodeURIComponent(String(reactionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsDeleteForTeamDiscussionComment.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsDeleteForTeamDiscussionComment.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsDeleteForTeamDiscussionComment.');
        }

        // verify required parameter 'commentNumber' is not null or undefined
        if (commentNumber === null || commentNumber === undefined) {
            throw new Error('Required parameter commentNumber was null or undefined when calling reactionsDeleteForTeamDiscussionComment.');
        }

        // verify required parameter 'reactionId' is not null or undefined
        if (reactionId === null || reactionId === undefined) {
            throw new Error('Required parameter reactionId was null or undefined when calling reactionsDeleteForTeamDiscussionComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
     * @summary List reactions for a commit comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForCommitComment (owner: string, repo: string, commentId: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsListForCommitComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsListForCommitComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsListForCommitComment.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
     * @summary List reactions for an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForIssue (owner: string, repo: string, issueNumber: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsListForIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsListForIssue.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling reactionsListForIssue.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
     * @summary List reactions for an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForIssueComment (owner: string, repo: string, commentId: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsListForIssueComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsListForIssueComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsListForIssueComment.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
     * @summary List reactions for a pull request review comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForPullRequestReviewComment (owner: string, repo: string, commentId: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsListForPullRequestReviewComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsListForPullRequestReviewComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reactionsListForPullRequestReviewComment.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to a [release](https://docs.github.com/rest/reference/repos#releases).
     * @summary List reactions for a release
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param releaseId The unique identifier of the release.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a release.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForRelease (owner: string, repo: string, releaseId: number, content?: '+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{release_id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'release_id' + '}', encodeURIComponent(String(releaseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reactionsListForRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reactionsListForRelease.');
        }

        // verify required parameter 'releaseId' is not null or undefined
        if (releaseId === null || releaseId === undefined) {
            throw new Error('Required parameter releaseId was null or undefined when calling reactionsListForRelease.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).  **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
     * @summary List reactions for a team discussion comment
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param commentNumber The number that identifies the comment.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForTeamDiscussionCommentInOrg (org: string, teamSlug: string, discussionNumber: number, commentNumber: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'comment_number' + '}', encodeURIComponent(String(commentNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsListForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsListForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsListForTeamDiscussionCommentInOrg.');
        }

        // verify required parameter 'commentNumber' is not null or undefined
        if (commentNumber === null || commentNumber === undefined) {
            throw new Error('Required parameter commentNumber was null or undefined when calling reactionsListForTeamDiscussionCommentInOrg.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.  List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @summary List reactions for a team discussion comment (Legacy)
     * @param teamId The unique identifier of the team.
     * @param discussionNumber The number that identifies the discussion.
     * @param commentNumber The number that identifies the comment.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForTeamDiscussionCommentLegacy (teamId: number, discussionNumber: number, commentNumber: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions'
            .replace('{' + 'team_id' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)))
            .replace('{' + 'comment_number' + '}', encodeURIComponent(String(commentNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling reactionsListForTeamDiscussionCommentLegacy.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsListForTeamDiscussionCommentLegacy.');
        }

        // verify required parameter 'commentNumber' is not null or undefined
        if (commentNumber === null || commentNumber === undefined) {
            throw new Error('Required parameter commentNumber was null or undefined when calling reactionsListForTeamDiscussionCommentLegacy.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).  **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
     * @summary List reactions for a team discussion
     * @param org The organization name. The name is not case sensitive.
     * @param teamSlug The slug of the team name.
     * @param discussionNumber The number that identifies the discussion.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForTeamDiscussionInOrg (org: string, teamSlug: string, discussionNumber: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'team_slug' + '}', encodeURIComponent(String(teamSlug)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling reactionsListForTeamDiscussionInOrg.');
        }

        // verify required parameter 'teamSlug' is not null or undefined
        if (teamSlug === null || teamSlug === undefined) {
            throw new Error('Required parameter teamSlug was null or undefined when calling reactionsListForTeamDiscussionInOrg.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsListForTeamDiscussionInOrg.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.  List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @summary List reactions for a team discussion (Legacy)
     * @param teamId The unique identifier of the team.
     * @param discussionNumber The number that identifies the discussion.
     * @param content Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async reactionsListForTeamDiscussionLegacy (teamId: number, discussionNumber: number, content?: '+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/teams/{team_id}/discussions/{discussion_number}/reactions'
            .replace('{' + 'team_id' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'discussion_number' + '}', encodeURIComponent(String(discussionNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling reactionsListForTeamDiscussionLegacy.');
        }

        // verify required parameter 'discussionNumber' is not null or undefined
        if (discussionNumber === null || discussionNumber === undefined) {
            throw new Error('Required parameter discussionNumber was null or undefined when calling reactionsListForTeamDiscussionLegacy.');
        }

        if (content !== undefined) {
            localVarQueryParameters['content'] = ObjectSerializer.serialize(content, "'+1' | '-1' | 'laugh' | 'confused' | 'heart' | 'hooray' | 'rocket' | 'eyes'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
