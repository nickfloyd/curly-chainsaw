/**
 * GitHub v3 REST API
 * GitHub\'s v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BasicError } from '../model/basicError';
import { CodeScanningListAlertsForEnterprise503Response } from '../model/codeScanningListAlertsForEnterprise503Response';
import { Issue } from '../model/issue';
import { IssueComment } from '../model/issueComment';
import { IssueEvent } from '../model/issueEvent';
import { IssueEventForIssue } from '../model/issueEventForIssue';
import { IssuesAddAssigneesRequest } from '../model/issuesAddAssigneesRequest';
import { IssuesAddLabelsRequest } from '../model/issuesAddLabelsRequest';
import { IssuesCreateLabelRequest } from '../model/issuesCreateLabelRequest';
import { IssuesCreateMilestoneRequest } from '../model/issuesCreateMilestoneRequest';
import { IssuesCreateRequest } from '../model/issuesCreateRequest';
import { IssuesLockRequest } from '../model/issuesLockRequest';
import { IssuesRemoveAssigneesRequest } from '../model/issuesRemoveAssigneesRequest';
import { IssuesSetLabelsRequest } from '../model/issuesSetLabelsRequest';
import { IssuesUpdateCommentRequest } from '../model/issuesUpdateCommentRequest';
import { IssuesUpdateLabelRequest } from '../model/issuesUpdateLabelRequest';
import { IssuesUpdateMilestoneRequest } from '../model/issuesUpdateMilestoneRequest';
import { IssuesUpdateRequest } from '../model/issuesUpdateRequest';
import { Label } from '../model/label';
import { Milestone1 } from '../model/milestone1';
import { SimpleUser1 } from '../model/simpleUser1';
import { TimelineEvent } from '../model/timelineEvent';
import { ValidationError } from '../model/validationError';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.github.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum IssuesApiApiKeys {
}

export class IssuesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: IssuesApiApiKeys, value: string) {
        (this.authentications as any)[IssuesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
     * @summary Add assignees to an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesAddAssigneesRequest 
     */
    public async issuesAddAssignees (owner: string, repo: string, issueNumber: number, issuesAddAssigneesRequest?: IssuesAddAssigneesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/assignees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesAddAssignees.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesAddAssignees.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesAddAssignees.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesAddAssigneesRequest, "IssuesAddAssigneesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Issue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Add labels to an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesAddLabelsRequest 
     */
    public async issuesAddLabels (owner: string, repo: string, issueNumber: number, issuesAddLabelsRequest?: IssuesAddLabelsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesAddLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesAddLabels.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesAddLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesAddLabelsRequest, "IssuesAddLabelsRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Checks if a user has permission to be assigned to an issue in this repository.  If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.  Otherwise a `404` status code is returned.
     * @summary Check if a user can be assigned
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param assignee 
     */
    public async issuesCheckUserCanBeAssigned (owner: string, repo: string, assignee: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/assignees/{assignee}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'assignee' + '}', encodeURIComponent(String(assignee)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesCheckUserCanBeAssigned.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesCheckUserCanBeAssigned.');
        }

        // verify required parameter 'assignee' is not null or undefined
        if (assignee === null || assignee === undefined) {
            throw new Error('Required parameter assignee was null or undefined when calling issuesCheckUserCanBeAssigned.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.  This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.
     * @summary Create an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issuesCreateRequest 
     */
    public async issuesCreate (owner: string, repo: string, issuesCreateRequest: IssuesCreateRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesCreate.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesCreate.');
        }

        // verify required parameter 'issuesCreateRequest' is not null or undefined
        if (issuesCreateRequest === null || issuesCreateRequest === undefined) {
            throw new Error('Required parameter issuesCreateRequest was null or undefined when calling issuesCreate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesCreateRequest, "IssuesCreateRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Issue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.
     * @summary Create an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesUpdateCommentRequest 
     */
    public async issuesCreateComment (owner: string, repo: string, issueNumber: number, issuesUpdateCommentRequest: IssuesUpdateCommentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssueComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesCreateComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesCreateComment.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesCreateComment.');
        }

        // verify required parameter 'issuesUpdateCommentRequest' is not null or undefined
        if (issuesUpdateCommentRequest === null || issuesUpdateCommentRequest === undefined) {
            throw new Error('Required parameter issuesUpdateCommentRequest was null or undefined when calling issuesCreateComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesUpdateCommentRequest, "IssuesUpdateCommentRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssueComment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssueComment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Create a label
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issuesCreateLabelRequest 
     */
    public async issuesCreateLabel (owner: string, repo: string, issuesCreateLabelRequest: IssuesCreateLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesCreateLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesCreateLabel.');
        }

        // verify required parameter 'issuesCreateLabelRequest' is not null or undefined
        if (issuesCreateLabelRequest === null || issuesCreateLabelRequest === undefined) {
            throw new Error('Required parameter issuesCreateLabelRequest was null or undefined when calling issuesCreateLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesCreateLabelRequest, "IssuesCreateLabelRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Label");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Create a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issuesCreateMilestoneRequest 
     */
    public async issuesCreateMilestone (owner: string, repo: string, issuesCreateMilestoneRequest: IssuesCreateMilestoneRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Milestone1;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesCreateMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesCreateMilestone.');
        }

        // verify required parameter 'issuesCreateMilestoneRequest' is not null or undefined
        if (issuesCreateMilestoneRequest === null || issuesCreateMilestoneRequest === undefined) {
            throw new Error('Required parameter issuesCreateMilestoneRequest was null or undefined when calling issuesCreateMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesCreateMilestoneRequest, "IssuesCreateMilestoneRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Milestone1;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Milestone1");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     */
    public async issuesDeleteComment (owner: string, repo: string, commentId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesDeleteComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesDeleteComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling issuesDeleteComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete a label
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param name 
     */
    public async issuesDeleteLabel (owner: string, repo: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesDeleteLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesDeleteLabel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling issuesDeleteLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     */
    public async issuesDeleteMilestone (owner: string, repo: string, milestoneNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{milestone_number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'milestone_number' + '}', encodeURIComponent(String(milestoneNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesDeleteMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesDeleteMilestone.');
        }

        // verify required parameter 'milestoneNumber' is not null or undefined
        if (milestoneNumber === null || milestoneNumber === undefined) {
            throw new Error('Required parameter milestoneNumber was null or undefined when calling issuesDeleteMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.  **Note**: GitHub\'s REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.
     * @summary Get an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     */
    public async issuesGet (owner: string, repo: string, issueNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Issue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     */
    public async issuesGetComment (owner: string, repo: string, commentId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssueComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesGetComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesGetComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling issuesGetComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssueComment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssueComment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get an issue event
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param eventId 
     */
    public async issuesGetEvent (owner: string, repo: string, eventId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssueEvent;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/events/{event_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'event_id' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesGetEvent.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesGetEvent.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling issuesGetEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssueEvent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssueEvent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get a label
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param name 
     */
    public async issuesGetLabel (owner: string, repo: string, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesGetLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesGetLabel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling issuesGetLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Label");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     */
    public async issuesGetMilestone (owner: string, repo: string, milestoneNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Milestone1;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{milestone_number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'milestone_number' + '}', encodeURIComponent(String(milestoneNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesGetMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesGetMilestone.');
        }

        // verify required parameter 'milestoneNumber' is not null or undefined
        if (milestoneNumber === null || milestoneNumber === undefined) {
            throw new Error('Required parameter milestoneNumber was null or undefined when calling issuesGetMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Milestone1;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Milestone1");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List issues assigned to the authenticated user across all visible repositories including owned repositories, member repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not necessarily assigned to you.   **Note**: GitHub\'s REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.
     * @summary List issues assigned to the authenticated user
     * @param filter Indicates which sorts of issues to return. &#x60;assigned&#x60; means issues assigned to you. &#x60;created&#x60; means issues created by you. &#x60;mentioned&#x60; means issues mentioning you. &#x60;subscribed&#x60; means issues you\&#39;re subscribed to updates for. &#x60;all&#x60; or &#x60;repos&#x60; means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return. Can be either &#x60;open&#x60;, &#x60;closed&#x60;, or &#x60;all&#x60;.
     * @param labels A list of comma separated label names. Example: &#x60;bug,ui,@high&#x60;
     * @param sort What to sort results by. Can be either &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;comments&#x60;.
     * @param direction The direction to sort the results by.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param collab 
     * @param orgs 
     * @param owned 
     * @param pulls 
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesList (filter?: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all', state?: 'open' | 'closed' | 'all', labels?: string, sort?: 'created' | 'updated' | 'comments', direction?: 'asc' | 'desc', since?: Date, collab?: boolean, orgs?: boolean, owned?: boolean, pulls?: boolean, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/issues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed' | 'all'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (collab !== undefined) {
            localVarQueryParameters['collab'] = ObjectSerializer.serialize(collab, "boolean");
        }

        if (orgs !== undefined) {
            localVarQueryParameters['orgs'] = ObjectSerializer.serialize(orgs, "boolean");
        }

        if (owned !== undefined) {
            localVarQueryParameters['owned'] = ObjectSerializer.serialize(owned, "boolean");
        }

        if (pulls !== undefined) {
            localVarQueryParameters['pulls'] = ObjectSerializer.serialize(pulls, "boolean");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Issue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
     * @summary List assignees
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListAssignees (owner: string, repo: string, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<SimpleUser1>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/assignees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListAssignees.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListAssignees.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<SimpleUser1>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<SimpleUser1>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Issue Comments are ordered by ascending ID.
     * @summary List issue comments
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListComments (owner: string, repo: string, issueNumber: number, since?: Date, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<IssueComment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListComments.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListComments.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesListComments.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<IssueComment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<IssueComment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * By default, Issue Comments are ordered by ascending ID.
     * @summary List issue comments for a repository
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param sort The property to sort the results by. &#x60;created&#x60; means when the repository was starred. &#x60;updated&#x60; means when the repository was last pushed to.
     * @param direction Either &#x60;asc&#x60; or &#x60;desc&#x60;. Ignored without the &#x60;sort&#x60; parameter.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListCommentsForRepo (owner: string, repo: string, sort?: 'created' | 'updated', direction?: 'asc' | 'desc', since?: Date, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<IssueComment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListCommentsForRepo.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListCommentsForRepo.');
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<IssueComment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<IssueComment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List issue events
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListEvents (owner: string, repo: string, issueNumber: number, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<IssueEventForIssue>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListEvents.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListEvents.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesListEvents.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<IssueEventForIssue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<IssueEventForIssue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List issue events for a repository
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListEventsForRepo (owner: string, repo: string, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<IssueEvent>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListEventsForRepo.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListEventsForRepo.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<IssueEvent>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<IssueEvent>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List timeline events for an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListEventsForTimeline (owner: string, repo: string, issueNumber: number, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<TimelineEvent>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/timeline'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListEventsForTimeline.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListEventsForTimeline.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesListEventsForTimeline.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<TimelineEvent>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<TimelineEvent>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List issues across owned and member repositories assigned to the authenticated user.  **Note**: GitHub\'s REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.
     * @summary List user account issues assigned to the authenticated user
     * @param filter Indicates which sorts of issues to return. &#x60;assigned&#x60; means issues assigned to you. &#x60;created&#x60; means issues created by you. &#x60;mentioned&#x60; means issues mentioning you. &#x60;subscribed&#x60; means issues you\&#39;re subscribed to updates for. &#x60;all&#x60; or &#x60;repos&#x60; means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return. Can be either &#x60;open&#x60;, &#x60;closed&#x60;, or &#x60;all&#x60;.
     * @param labels A list of comma separated label names. Example: &#x60;bug,ui,@high&#x60;
     * @param sort What to sort results by. Can be either &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;comments&#x60;.
     * @param direction The direction to sort the results by.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListForAuthenticatedUser (filter?: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all', state?: 'open' | 'closed' | 'all', labels?: string, sort?: 'created' | 'updated' | 'comments', direction?: 'asc' | 'desc', since?: Date, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/user/issues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed' | 'all'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Issue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List issues in an organization assigned to the authenticated user.  **Note**: GitHub\'s REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.
     * @summary List organization issues assigned to the authenticated user
     * @param org The organization name. The name is not case sensitive.
     * @param filter Indicates which sorts of issues to return. &#x60;assigned&#x60; means issues assigned to you. &#x60;created&#x60; means issues created by you. &#x60;mentioned&#x60; means issues mentioning you. &#x60;subscribed&#x60; means issues you\&#39;re subscribed to updates for. &#x60;all&#x60; or &#x60;repos&#x60; means all issues you can see, regardless of participation or creation.
     * @param state Indicates the state of the issues to return. Can be either &#x60;open&#x60;, &#x60;closed&#x60;, or &#x60;all&#x60;.
     * @param labels A list of comma separated label names. Example: &#x60;bug,ui,@high&#x60;
     * @param sort What to sort results by. Can be either &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;comments&#x60;.
     * @param direction The direction to sort the results by.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListForOrg (org: string, filter?: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all', state?: 'open' | 'closed' | 'all', labels?: string, sort?: 'created' | 'updated' | 'comments', direction?: 'asc' | 'desc', since?: Date, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/issues'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling issuesListForOrg.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'repos' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed' | 'all'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Issue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List issues in a repository.  **Note**: GitHub\'s REST API v3 considers every pull request an issue, but not every issue is a pull request. For this reason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull request id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.
     * @summary List repository issues
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param milestone If an &#x60;integer&#x60; is passed, it should refer to a milestone by its &#x60;number&#x60; field. If the string &#x60;*&#x60; is passed, issues with any milestone are accepted. If the string &#x60;none&#x60; is passed, issues without milestones are returned.
     * @param state Indicates the state of the issues to return. Can be either &#x60;open&#x60;, &#x60;closed&#x60;, or &#x60;all&#x60;.
     * @param assignee Can be the name of a user. Pass in &#x60;none&#x60; for issues with no assigned user, and &#x60;*&#x60; for issues assigned to any user.
     * @param creator The user that created the issue.
     * @param mentioned A user that\&#39;s mentioned in the issue.
     * @param labels A list of comma separated label names. Example: &#x60;bug,ui,@high&#x60;
     * @param sort What to sort results by. Can be either &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;comments&#x60;.
     * @param direction The direction to sort the results by.
     * @param since Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListForRepo (owner: string, repo: string, milestone?: string, state?: 'open' | 'closed' | 'all', assignee?: string, creator?: string, mentioned?: string, labels?: string, sort?: 'created' | 'updated' | 'comments', direction?: 'asc' | 'desc', since?: Date, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListForRepo.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListForRepo.');
        }

        if (milestone !== undefined) {
            localVarQueryParameters['milestone'] = ObjectSerializer.serialize(milestone, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed' | 'all'");
        }

        if (assignee !== undefined) {
            localVarQueryParameters['assignee'] = ObjectSerializer.serialize(assignee, "string");
        }

        if (creator !== undefined) {
            localVarQueryParameters['creator'] = ObjectSerializer.serialize(creator, "string");
        }

        if (mentioned !== undefined) {
            localVarQueryParameters['mentioned'] = ObjectSerializer.serialize(mentioned, "string");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Issue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List labels for issues in a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListLabelsForMilestone (owner: string, repo: string, milestoneNumber: number, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{milestone_number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'milestone_number' + '}', encodeURIComponent(String(milestoneNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListLabelsForMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListLabelsForMilestone.');
        }

        // verify required parameter 'milestoneNumber' is not null or undefined
        if (milestoneNumber === null || milestoneNumber === undefined) {
            throw new Error('Required parameter milestoneNumber was null or undefined when calling issuesListLabelsForMilestone.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List labels for a repository
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListLabelsForRepo (owner: string, repo: string, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListLabelsForRepo.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListLabelsForRepo.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List labels for an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListLabelsOnIssue (owner: string, repo: string, issueNumber: number, perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListLabelsOnIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListLabelsOnIssue.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesListLabelsOnIssue.');
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List milestones
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param state The state of the milestone. Either &#x60;open&#x60;, &#x60;closed&#x60;, or &#x60;all&#x60;.
     * @param sort What to sort results by. Either &#x60;due_on&#x60; or &#x60;completeness&#x60;.
     * @param direction The direction of the sort. Either &#x60;asc&#x60; or &#x60;desc&#x60;.
     * @param perPage The number of results per page (max 100).
     * @param page Page number of the results to fetch.
     */
    public async issuesListMilestones (owner: string, repo: string, state?: 'open' | 'closed' | 'all', sort?: 'due_on' | 'completeness', direction?: 'asc' | 'desc', perPage?: number, page?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Milestone1>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesListMilestones.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesListMilestones.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed' | 'all'");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'due_on' | 'completeness'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Milestone1>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Milestone1>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Users with push access can lock an issue or pull request\'s conversation.  Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"
     * @summary Lock an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesLockRequest 
     */
    public async issuesLock (owner: string, repo: string, issueNumber: number, issuesLockRequest?: IssuesLockRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/lock'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesLock.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesLock.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesLock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesLockRequest, "IssuesLockRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Remove all labels from an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     */
    public async issuesRemoveAllLabels (owner: string, repo: string, issueNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesRemoveAllLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesRemoveAllLabels.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesRemoveAllLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes one or more assignees from an issue.
     * @summary Remove assignees from an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesRemoveAssigneesRequest 
     */
    public async issuesRemoveAssignees (owner: string, repo: string, issueNumber: number, issuesRemoveAssigneesRequest?: IssuesRemoveAssigneesRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/assignees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesRemoveAssignees.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesRemoveAssignees.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesRemoveAssignees.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesRemoveAssigneesRequest, "IssuesRemoveAssigneesRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Issue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
     * @summary Remove a label from an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param name 
     */
    public async issuesRemoveLabel (owner: string, repo: string, issueNumber: number, name: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesRemoveLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesRemoveLabel.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesRemoveLabel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling issuesRemoveLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes any previous labels and sets the new labels for an issue.
     * @summary Set labels for an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesSetLabelsRequest 
     */
    public async issuesSetLabels (owner: string, repo: string, issueNumber: number, issuesSetLabelsRequest?: IssuesSetLabelsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesSetLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesSetLabels.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesSetLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesSetLabelsRequest, "IssuesSetLabelsRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Label>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Users with push access can unlock an issue\'s conversation.
     * @summary Unlock an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     */
    public async issuesUnlock (owner: string, repo: string, issueNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}/lock'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesUnlock.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesUnlock.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesUnlock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Issue owners and users with push access can edit an issue.
     * @summary Update an issue
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param issueNumber The number that identifies the issue.
     * @param issuesUpdateRequest 
     */
    public async issuesUpdate (owner: string, repo: string, issueNumber: number, issuesUpdateRequest?: IssuesUpdateRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{issue_number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'issue_number' + '}', encodeURIComponent(String(issueNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesUpdate.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesUpdate.');
        }

        // verify required parameter 'issueNumber' is not null or undefined
        if (issueNumber === null || issueNumber === undefined) {
            throw new Error('Required parameter issueNumber was null or undefined when calling issuesUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesUpdateRequest, "IssuesUpdateRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Issue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Update an issue comment
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param commentId The unique identifier of the comment.
     * @param issuesUpdateCommentRequest 
     */
    public async issuesUpdateComment (owner: string, repo: string, commentId: number, issuesUpdateCommentRequest: IssuesUpdateCommentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssueComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{comment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesUpdateComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesUpdateComment.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling issuesUpdateComment.');
        }

        // verify required parameter 'issuesUpdateCommentRequest' is not null or undefined
        if (issuesUpdateCommentRequest === null || issuesUpdateCommentRequest === undefined) {
            throw new Error('Required parameter issuesUpdateCommentRequest was null or undefined when calling issuesUpdateComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesUpdateCommentRequest, "IssuesUpdateCommentRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssueComment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssueComment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Update a label
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param name 
     * @param issuesUpdateLabelRequest 
     */
    public async issuesUpdateLabel (owner: string, repo: string, name: string, issuesUpdateLabelRequest?: IssuesUpdateLabelRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesUpdateLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesUpdateLabel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling issuesUpdateLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesUpdateLabelRequest, "IssuesUpdateLabelRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Label");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Update a milestone
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param milestoneNumber The number that identifies the milestone.
     * @param issuesUpdateMilestoneRequest 
     */
    public async issuesUpdateMilestone (owner: string, repo: string, milestoneNumber: number, issuesUpdateMilestoneRequest?: IssuesUpdateMilestoneRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Milestone1;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{milestone_number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'milestone_number' + '}', encodeURIComponent(String(milestoneNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuesUpdateMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuesUpdateMilestone.');
        }

        // verify required parameter 'milestoneNumber' is not null or undefined
        if (milestoneNumber === null || milestoneNumber === undefined) {
            throw new Error('Required parameter milestoneNumber was null or undefined when calling issuesUpdateMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(issuesUpdateMilestoneRequest, "IssuesUpdateMilestoneRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Milestone1;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Milestone1");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
