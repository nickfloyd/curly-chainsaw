/**
 * GitHub v3 REST API
 * GitHub\'s v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BasicError } from '../model/basicError';
import { DependencyGraphCreateRepositorySnapshot201Response } from '../model/dependencyGraphCreateRepositorySnapshot201Response';
import { DependencyGraphDiffInner } from '../model/dependencyGraphDiffInner';
import { Snapshot } from '../model/snapshot';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.github.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DependencyGraphApiApiKeys {
}

export class DependencyGraphApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DependencyGraphApiApiKeys, value: string) {
        (this.authentications as any)[DependencyGraphApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a new snapshot of a repository\'s dependencies. You must authenticate using an access token with the `repo` scope to use this endpoint for a repository that the requesting user has access to.
     * @summary Create a snapshot of dependencies for a repository
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param snapshot 
     */
    public async dependencyGraphCreateRepositorySnapshot (owner: string, repo: string, snapshot: Snapshot, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DependencyGraphCreateRepositorySnapshot201Response;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/dependency-graph/snapshots'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling dependencyGraphCreateRepositorySnapshot.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling dependencyGraphCreateRepositorySnapshot.');
        }

        // verify required parameter 'snapshot' is not null or undefined
        if (snapshot === null || snapshot === undefined) {
            throw new Error('Required parameter snapshot was null or undefined when calling dependencyGraphCreateRepositorySnapshot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(snapshot, "Snapshot")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DependencyGraphCreateRepositorySnapshot201Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DependencyGraphCreateRepositorySnapshot201Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits.
     * @summary Get a diff of the dependencies between commits
     * @param owner The account owner of the repository. The name is not case sensitive.
     * @param repo The name of the repository. The name is not case sensitive.
     * @param basehead The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format &#x60;{base}...{head}&#x60;.
     * @param name The full path, relative to the repository root, of the dependency manifest file.
     */
    public async dependencyGraphDiffRange (owner: string, repo: string, basehead: string, name?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<DependencyGraphDiffInner>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/dependency-graph/compare/{basehead}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'basehead' + '}', encodeURIComponent(String(basehead)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling dependencyGraphDiffRange.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling dependencyGraphDiffRange.');
        }

        // verify required parameter 'basehead' is not null or undefined
        if (basehead === null || basehead === undefined) {
            throw new Error('Required parameter basehead was null or undefined when calling dependencyGraphDiffRange.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<DependencyGraphDiffInner>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<DependencyGraphDiffInner>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
